**进程是资源分配的最小单位，线程是CPU调度的最小单位**

**我们开启一个页签去打开网页，这就是开了一个浏览器渲染进程，而多个不同的模块去处理这个网页，比如，js解析模块，http请求模块等，这就是多个线程**，而且这多个线程还能协同工作



为什么浏览器需要异步

js是单线程的语言，且没有异步的特性。那么，在一些复杂的场景中，比如，定时任务，比如http等延时任务，必须通过异步来解决，于是，js 的宿主浏览器必须承担起这个责任，异步应运而生。



| 特性         | 宏任务（Macro Task）                                         | 微任务（Micro Task）                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**     | 任务队列中的大任务，执行完一个后再检查微任务队列             | 执行完当前宏任务后立即执行的任务                             |
| **执行时机** | 事件循环的每个 tick 只执行一个宏任务，执行完后再执行微任务   | 在当前宏任务执行完后，事件循环检查并执行所有微任务           |
| **示例**     | `setTimeout`、`setInterval`、`setImmediate`（Node.js）、`requestAnimationFrame`、I/O 操作 | `Promise.then`、`MutationObserver`、`process.nextTick`（Node.js） |
| **优先级**   | 低（下一轮事件循环才执行）                                   | 高（当前宏任务执行完立即执行）                               |
| **执行顺序** | 事件循环每轮执行 **一个** 宏任务，执行完后清空所有微任务队列 | 每次宏任务执行完，立即执行所有微任务                         |
| **应用场景** | 定时任务、用户交互、网络请求回调                             | 处理异步逻辑、Promise 链式调用                               |

**💡 执行顺序**

浏览器的 **事件循环（Event Loop）** 大致按照以下顺序运行：

1. **执行同步代码（Script）** 
2. **执行所有微任务（Microtasks）**例如：Promise.then()、MutationObserver
3. **执行渲染（Rendering）**计算样式（Recalculate Style）生成布局（Layout / Reflow）绘制（Painting）
4. **执行下一个宏任务（Macrotask）**例如：setTimeout、setInterval、I/O 任务
5. **进入下一轮事件循环**

之所以有微任务和宏任务的区分，是由于像promise等微任务是es的规范，并不是浏览器的规范，而想settiemout是浏览器的api规范，此时，为什么就清晰明了了，由于微任务是es的规范，那么即使是异步，也是js解析处理，所以，不会被算在eventloop开始之后



### 垃圾回收机制

##### 标记清除法

1. **标记阶段（Mark）**：GC 从 **根对象**（如 window 或 global）开始，遍历所有可达对象，并做上标记。
2. **清除阶段（Sweep）**：GC 释放 **没有被标记的对象**，回收它们占用的内存。

##### 引用计数

- 每个对象都有一个 **引用计数** 。
- 当 **另一个对象引用它时**，计数 **+1**。
- 当 **引用被移除** 时，计数 **-1**。
- **计数为 0** 时，回收对象。

#### V8分代垃圾回收策略(**Generational Garbage Collection**)

V8采用了一种代回收的策略，将内存分为两个生代：**新生代（new generation）**和**老生代（old generation）**。



### 浏览器缓存机制

https://www.jianshu.com/p/54cc04190252