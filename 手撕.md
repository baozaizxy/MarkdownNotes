- `call/apply/bind` - 对`this`指向的理解
- 手写`promise` - 对异步的理解
- 手写原生`ajax` - 对`ajax`原理和`http`请求方式的理解，重点是`get`和`post`请求的实现

##### Promise

new Promise((resolve, reject) => {...}) **创建一个新的 Promise 对象**，它接收一个**执行器函数** (resolve, reject) => {...} 作为参数。

- **resolve(value)**：使 Promise 变为 **fulfilled（已完成）** 状态，并返回 value
- **reject(reason)**：使 Promise 变为 **rejected（已拒绝）** 状态，并返回 reason。

**实现Promise.resolve**

```js
Promise.resolve = (param) => {
  if(param instanceof Promise){
    return param;
  }
  return new Promise((resolve, reject)=> {
    if(param && param.then && typeof param.then === 'function'){
      // 如果 param 是 Thenable，调用它的 then 方法
      params.then(resolve, reject);
    } else {
      // 让新创建的 Promise 直接进入 fulfilled 状态，并携带 param 作为结果。
      resolve(param);
    }
  } )
}
```

**实现Promise.reject**

```js
Promise.reject((reson)=>{
  return new Promise((resolve, reject) => {
    reject(reason)
  })
})
```

**实现Promise.prototype.finally**

**finally 是实例方法**，因为它是在已存在的 Promise 实例上执行的，用来处理完成时的副作用，并且不改变原 Promise 的最终结果。

在 JavaScript 中，Promise 类使用了静态方法（例如 Promise.resolve()、Promise.reject() 和 Promise.all()）来创建新的 Promise 实例，而 finally 则是作为实例方法放在原型上，因为它作用于已经存在的 Promise 实例，用来在 Promise 完成时执行一些副作用。


- `finally`里的回调函数，无论如何都会执行，并会把前面的值原封不动传递给下一个`then`方法中
- 如果`finally`函数中有`promise`等异步任务，会等它们全部执行完毕，再结合之前的成功与否状态，返回值

```js
Promise.prototype.finally = function(callback) {
  return this.then(
    (data) => {
      return Promise.resolve(callback()).then(() => data); // 保留原始 Promise 的成功值
    },
    (err) => {
      return Promise.resolve(callback()).then(() => {
        throw err; // 保留原始 Promise 的失败错误
      });
    }
  );
}
```

**实现Promise.all**

```js
Promise.all = function(promises) {
  return new Promise((resolve, reject) => {
    let result = [];
    let index = 0;
    let len = promises.length;
    if(len === 0) {
      resolve(result);
      return;
    }
   
    for(let i = 0; i < len; i++) {
      // 为什么不直接 promise[i].then, 因为promise[i]可能不是一个promise
      // 如果 promises[i] 是一个普通的值（而不是一个 Promise），Promise.resolve 会将其转换为一个已解析的 Promise。
      Promise.resolve(promise[i]).then(data => {
        result[i] = data;
        index++;
        if(index === len) resolve(result);
      }).catch(err => {
        reject(err);
      })
    }
  })
}

```

**实现Promise.allsettle**

```js
function isPromise (val) {
  return typeof val.then === 'function'; // (123).then => undefined
}

Promise.allSettled = function(promises) {
  return new Promise((resolve, reject) => {
    // arr 用来存储每个 Promise 的状态和结果
    let arr = [];
    // times 用来记录已完成（成功或失败）的 Promise 数量，确保在所有 Promise 完成时，resolve 会被调用，返回包含每个 Promise 状态的数组。
    let times = 0;
    const setData = (index, data) => {
      arr[index] = data;
      if (++times === promises.length) {
        resolve(arr);
      }
    }

    for (let i = 0; i < promises.length; i++) {
      let current = promises[i];
      if (isPromise(current)) {
        current.then((data) => {
          setData(i, { status: 'fulfilled', value: data });
        }, err => {
          setData(i, { status: 'rejected', value: err })
        })
      } else {
        setData(i, { status: 'fulfilled', value: current })
      }
    }
  })
}

```

**实现Promise.allsettle**

```js
Promise.race = function(promises) {
  return new Promise((resolve, reject) => {
    let len = promises.length;
    if(len === 0) return;
    for(let i = 0; i < len; i++) {
      Promise.resolve(promise[i]).then(data => {
        resolve(data);
        return;
      }).catch(err => {
        reject(err);
        return;
      })
    }
  })
}

```



##### 防抖

```js
// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
  // 缓存一个定时器id
  let timer = 0
  // 这里返回的函数是每次用户实际调用的防抖函数
  // 如果已经设定过定时器了就清空上一次的定时器
  // 开始一个新的定时器，延迟执行用户传入的方法
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}

```



##### 手写new

```js
function myNew(constructor, ...args) {
    // 1. 创建一个新的空对象，并把它的 `__proto__` 关联到构造函数的 `prototype`
    const obj = Object.create(constructor.prototype);
    
    // 2. 调用构造函数，并将 `this` 绑定到新创建的对象
    const result = constructor.apply(obj, args);
    
    // 3. 如果构造函数返回的是对象，则返回该对象，否则返回新创建的对象
    return result instanceof Object ? result : obj;
}
```

测试代码

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const person1 = myNew(Person, "Alice", 25);
console.log(person1.name); // Alice
console.log(person1.age);  // 25
console.log(person1 instanceof Person); // true
```



##### 正则的方式根据name获得cookie

```js
function getCookie(name) {
  var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)'));
  return match ? decodeURIComponent(match[2]) : null;
}
```



##### 手写call && apply && bind

**call**

```js
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== "function") {
    throw new TypeError("Not a function");
  }
  
  context = context || globalThis; // `null` 和 `undefined` 指向 `window` 或 `globalThis`
  const fnKey = Symbol(); // 用 Symbol 避免属性冲突
  context[fnKey] = this; // `this` 指向调用 `myCall` 的函数
  
  const result = context[fnKey](...args); // 执行函数
  delete context[fnKey]; // 删除临时属性，防止污染

  return result;
};

// ✅ 测试 `myCall`
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "Alice" };

greet.myCall(person, "Hello", "!"); // Hello, Alice!
```

**apply**

```js
Function.prototype.myApply = function (context, argsArray) {
  if (typeof this !== "function") {
    throw new TypeError("Not a function");
  }

  context = context || globalThis;
  const fnKey = Symbol();
  context[fnKey] = this;

  const result = argsArray ? context[fnKey](...argsArray) : context[fnKey](); // 处理 `undefined`
  delete context[fnKey];

  return result;
};

// ✅ 测试 `myApply`
greet.myApply(person, ["Hi", "."]); // Hi, Alice.
```

**bind**

```js
Function.prototype.myBind = function (context, ...bindArgs) {
  if (typeof this !== "function") {
    throw new TypeError("Not a function");
  }

  const self = this; // 保留原函数
  
  return function boundFunction(...callArgs) {
    return self.apply(context, [...bindArgs, ...callArgs]); // 组合参数
  };
};

// ✅ 测试 `myBind`
const boundGreet = greet.myBind(person, "Hey");
boundGreet("!!"); // Hey, Alice!!
```



##### 浅拷贝和深拷贝

- **浅拷贝**：仅复制对象的第一层属性，嵌套对象会共享引用。
- **深拷贝**：递归复制对象的所有属性，确保嵌套对象不共享引用。

浅拷贝只复制了对象或数组的**第一层属性**，如果某个属性值是对象或数组（即引用类型），那么**浅拷贝**会复制该属性的引用，而不是创建一个新的对象或数组。

```js
// 浅拷贝
const copy = (obj) => {
	let shallowCopy;
  // 或者const shallowCopy = { ...obj };
  for(let key in obj){
    shallowCopy[key] = obj[key];
  }
  return shallowCopy;
}
```



**使用 JSON.parse() 和 JSON.stringify()**实现深拷贝（适用于对象中没有函数、undefined 或特殊对象）：

```js
const obj = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(obj));
deepCopy.b.c = 3;

console.log(obj.b.c);  // 2
console.log(deepCopy.b.c);  // 3
```



**使用递归实现深拷贝**（适用于更复杂的情况）：

```js
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;  // 直接返回基本数据类型
  }

  // 创建一个新对象或数组
  const copy = Array.isArray(obj) ? [] : {};

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepClone(obj[key]);  // 递归拷贝
    }
  }
  
  return copy;
}

const obj = { a: 1, b: { c: 2 } };
const deepCopy = deepClone(obj);
deepCopy.b.c = 3;

console.log(obj.b.c);  // 2
console.log(deepCopy.b.c);  // 3
```



##### 计数器

```js

```



##### 版本号比较

```js

```



##### 手写数组扁平化、去重、排序



##### 大数相加



##### 柯里化



##### 数组相关

**实现forEach方法**

```js
Array.prototype.forEach = function(callback, context){
  let self = this,
      len = self.length;
  for(let i=0; i< len; i++){
    typeof callback === 'function' && callback.call(context??undefined, self[i], i)
  }
}
```

**实现filter方法**

```js
Array.prototype.filter = function(callback, context){
  const self = this,
        len = self.length;
  let newArray = [];
  for(let i = 0; i < len; i++){
    if(callback.apply(context??undefined, [self[i],i])){
      newArray.push(self[i]);
    }
  }
  return newArray;
}
```

**实现find方法**

```js
Array.prototype.find = function(callback){
  const self = this,
        len = self.length;
  for(let i =0; i < len; i++){
    if (callback(self[i], i)) {
      return self[i]
      // findIndex就return i
    }
  }
}
```

