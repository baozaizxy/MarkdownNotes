# 计算机网络

### HTTP篇

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

![State Image](/Users/sherryzheng_mac/Desktop/typora/aeeets/6-五大类HTTP状态码.webp)

​	•	**301 Moved Permanently**：请求的资源已经被永久移动到新的 URL，客户端以后应使用新的 URL。

​	•	**302 Found**：请求的资源临时被移到一个不同的 URL。

​	•	**304 Not Modified**：请求的资源没有修改，客户端可以使用缓存的版本。



​	•	**400 Bad Request**：服务器无法理解请求，通常是请求格式错误。

​	•	**401 Unauthorized**：需要用户身份验证，通常是由于缺少或错误的认证信息。

​	•	**403 Forbidden**：服务器理解请求，但拒绝执行它，通常是权限问题。

​	•	**404 Not Found**：请求的资源不存在，服务器无法找到。



​	•	**502 Bad Gateway**：服务器作为网关或代理时，从上游服务器收到无效响应。

​	•	**503 Service Unavailable**：服务器暂时无法处理请求，可能是因为过载或维护中。类似“网络繁忙 稍后再试”

​	•	**504 Gateway Timeout**：服务器作为网关或代理时，未能及时从上游服务器获取响应。

HTTP的不足之处

- HTTP 是**无状态协议**，服务器不会记录客户端的状态，每次请求都是独立的。这意味着：服务器无法直接记住用户的登录状态，必须依赖 **Cookie、Session、JWT** 等机制来管理会话。
- 数据以明文传输，攻击者可通过**中间人攻击（MITM）**窃取敏感数据，传输过程中，数据可能被劫持并篡改，例如**HTTP 劫持、DNS 劫持**等
- HTTP 每次请求都会携带大量头部信息（User-Agent、Cookie、Referer 等），启用 **HTTP/2**（头部压缩、二进制格式）可以解决
- 没有多路复用，容易阻塞，**使用 HTTP/2 多路复用**可以解决
- HTTP 是**基于请求-响应**的模式，服务器**无法主动向客户端推送数据**，客户端必须不断轮询或使用 WebSocket。



HTTPS:

HTTPS（**超文本传输安全协议**）是在 HTTP **基础上增加了 SSL/TLS 加密**的安全协议，主要用于保证数据在客户端（浏览器）和服务器之间的安全传输，防止窃听、篡改和劫持。

在正常情况下，`HTTP` 直接和 `TCP` 通信，当使用 `SSL` 时，则演变成先和 `SSL` 通信，再由 `SSL` 和 `TCP` 通信了，换句话说，所谓的 `HTTPS` 实际上就是身披 `SSL` 协议这层外壳的 `HTTP`。



### HTTP 常见字段

| 字段                            | 描述                                                         | 示例                                                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Host**                        | 请求的目标主机和端口。                                       | `Host: www.example.com`                                      |
| **User-Agent**                  | 浏览器或客户端的用户代理信息。                               | `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36` |
| **Accept**                      | 客户端能够接受的媒体类型（如文本、图像等）。                 | `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8` |
| **Accept-Encoding**             | 客户端支持的内容编码（压缩方式）。                           | `Accept-Encoding: gzip, deflate, br`                         |
| **Content-Type**                | 请求或响应体的媒体类型。                                     | `Content-Type: application/json`                             |
| **Content-Length**              | 请求或响应体的大小，单位是字节。                             | `Content-Length: 1234`                                       |
| **Authorization**               | 客户端向服务器发送的认证信息。                               | `Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l`              |
| **Cookie**                      | 客户端发送的 cookie 数据。                                   | `Cookie: user_id=abc123; session_id=xyz789`                  |
| **Location**                    | 用于重定向时，指定客户端应访问的 URL。                       | `Location: https://www.example.com/newpage`                  |
| **Cache-Control**               | 控制缓存的行为。                                             | `Cache-Control: no-cache, no-store, must-revalidate`         |
| **Pragma**                      | 旧版 HTTP 协议中的缓存控制字段，通常与 `Cache-Control` 一起使用。 | `Pragma: no-cache`                                           |
| **Expires**                     | 指定响应过期的日期和时间。                                   | `Expires: Wed, 21 Oct 2025 07:28:00 GMT`                     |
| **Set-Cookie**                  | 服务器发送到客户端的 cookie。                                | `Set-Cookie: sessionId=abc123; Path=/; HttpOnly`             |
| **If-Modified-Since**           | 请求的资源如果自指定的时间以来没有变化，则服务器返回 304 状态码。 | `If-Modified-Since: Sat, 29 Oct 2022 00:00:00 GMT`           |
| **Referer**                     | 发出请求的页面的 URL。                                       | `Referer: https://www.example.com/previouspage`              |
| **X-Requested-With**            | 用于标识异步请求（通常用于 Ajax 请求）。                     | `X-Requested-With: XMLHttpRequest`                           |
| **Access-Control-Allow-Origin** | 服务器允许哪些域名可以访问资源。                             | `Access-Control-Allow-Origin: *`                             |



#### HTTP的缓存技术

**强缓存**

强缓存是指浏览器直接使用缓存中的资源，而不向服务器发起请求。如果资源未过期，浏览器会直接使用本地缓存，完全跳过向服务器的请求。它依赖于 Cache-Control 和 Expires 这两个 HTTP 头部来进行缓存控制。

**Cache-Control:** max-age=<seconds>：表示资源的最大有效时间，单位是秒。例如 Cache-Control: max-age=3600 表示资源在缓存中保存 1 小时。

**Expires**: 资源的过期时间，指定一个日期和时间，超过这个时间，资源会被认为过期。

**协商缓存**

协商缓存是指浏览器在请求资源时，仍会向服务器发送请求，但会通过一些条件判断来决定是否使用缓存中的资源。只有在资源被修改的情况下，浏览器才会重新从服务器获取资源。

**Last-Modified**（值为资源最后更新时间，随服务器response返回）

**If-Modified-Since**: 发送请求时，浏览器会带上上次请求资源的 Last-Modified 时间戳。服务器通过这个时间判断资源是否已被修改。

**ETag（**表示资源内容的唯一标识，随服务器`response`返回）

**If-None-Match**: 发送请求时，浏览器会带上 ETag，这是服务器生成的资源标识符，通常是资源内容的 hash 值。服务器通过该值来判断资源是否变化。如果没变化，命中协商缓存



#### HTTP不同版本特性

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

##### HTTP1.1

Pros：简单、灵活和易于扩展

1. 持久链接

2. 管道化，一个连接中可以发送多个请求，而无需等待前一个请求的响应。可以**减少整体的响应时间。**

   **HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以**后面所有文章讨论 HTTP/1.1 都是建立在没有使用管道化的前提**。大家知道有这个功能，但是没有被使用就行了。

3. 允许响应体分块传输，使得大文件的处理更加高效，尤其是在数据生成和传输不确定时。

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

1. 无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

   无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

   对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。

   `Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

2. 明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

   但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。

   

##### HTTPS

HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险：

- **信息加密**：交互信息无法被窃取
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示
- **身份证书**：证明淘宝是真的淘宝网

HTTPS 是如何解决上面的三个风险的？

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。



**相对于HTTP1.0，HTTP1.1的优化**

- 缓存处理：多了`Entity tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match`等缓存信息（`HTTTP1.0 If-Modified-Since`,`Expires`）
- 带宽优化及网络连接的使用
- 错误通知的管理
- `Host`头处理
- 长连接： `HTTP1.1`中默认开启`Connection`： `keep-alive`，一定程度上弥补了`HTTP1.0`每次请求都要创建连接的缺点

**相对于HTTP1.1，HTTP2的优化**

- `HTTP2`支持二进制传送（实现方便且健壮），`HTTP1.x`是字符串传送
- `HTTP2`支持多路复用
- `HTTP2`采用`HPACK`压缩算法压缩头部，减小了传输的体积
- `HTTP2`支持服务端推送



**HTTP/2中的多路复用**

- 在HTTP/2协议中，引入了多路复用的概念，允许多个请求和响应同时通过同一个TCP连接进行传输，而不需要像HTTP/1.x那样每个请求都建立一个新的连接。这极大地提高了连接的效率，减少了延迟。
- 在HTTP/2中，多个请求和响应被分解为小的数据帧，这些数据帧可以并行发送和接收，从而解决了HTTP/1.x中的队头阻塞（Head-of-line Blocking）问题。



##### 对称加密**Symmetric Encryption**和非对称加密**Asymmetric Encryption**

用 **非对称加密**（RSA）**加密对称加密的密钥**，再用 **对称加密**（AES）加密实际数据。

这就是 **HTTPS** 里 TLS 传输加密的方式，既安全又高效！

先生成一个私钥，在根据**非对称加密的数学原理**根据私钥生成一个对应的公钥，公钥可以明文传输给客户端，因为从公钥无法得知私钥，用公钥加密后服务端使用私钥揭秘

公钥只用来加密，私钥只用来解密

 **TLS 握手总结：**

1. **客户端发送 ClientHello**，包括它支持的加密算法。
2. **服务器发送 ServerHello**，选择加密算法，并发送自己的公钥（或数字证书）。
3. **客户端生成对称密钥**，用服务器公钥加密后发送给服务器。
4. **服务器解密密钥**，获得对称加密密钥。
5. **双方使用对称加密** 进行安全的加密通信。



#### WebSocket

##### 既然有HTTP为什么还需要websocket

我们知道 TCP 连接的两端，**同一时间里**，**双方**都可以**主动**向对方发送数据。这就是所谓的**全双工**。

而现在使用最广泛的 `HTTP/1.1`，也是基于 TCP 协议的，**同一时间里**，客户端和服务器**只能有一方主动**发数据，这就是所谓的**半双工**。

也就是说，好好的全双工 TCP，被 HTTP/1.1 用成了半双工。

##### 如何建立websocket

浏览器在 **TCP 三次握手**建立连接之后，都**统一使用 HTTP 协议**先进行一次通信。

- 如果此时是**普通的 HTTP 请求**，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。
- 如果这时候是**想建立 WebSocket 连接**，就会在 HTTP 请求里带上一些**特殊的 header 头**，如下：

```http
Connection: Upgrade
Upgrade: WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n
```



#### websocket的使用场景

WebSocket 完美继承了 TCP 协议的**全双工**能力，支持持久连续，并且还贴心的提供了解决粘包的方案。

它适用于**需要服务器和客户端（浏览器）频繁交互**的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。



### TCP篇

 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

**UDP** 是一种无连接的协议，不像 TCP 那样保证数据的可靠性和顺序。它只是尽力将数据发送到目标，不做任何保证。TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接

![图片描述](/Users/sherryzheng_mac/Desktop/typora/aeeets/分层模型.png)

#### 三次握手四次挥手

三次握手：确保双方都能接收到的自己的数据 + 建立一个同步的序列号，用于后续的可靠传输

1. **SYN**：客户端发送一个带 SYN 标志的数据包给服务器，表示客户端请求建立连接。
   **客户端**：SYN (Sequence Number = X)

2. **SYN-ACK**：服务器收到客户端的 SYN 数据包后，服务器回复一个带 SYN 和 ACK 标志的数据包，表示接受连接请求。

   **服务器**：SYN (Sequence Number = Y), ACK (Acknowledgement Number = X + 1)

3. **ACK**：客户端收到服务器的 SYN-ACK 后，再发送一个 ACK 数据包给服务器，表示连接建立完成。

​	**客户端**：ACK (Acknowledgement Number = Y + 1)



四次挥手：

1. **FIN**：客户端发送一个带 FIN 标志的数据包给服务器，表示客户端没有数据发送，但仍然可以接收数据。
   **客户端**：FIN (Sequence Number = U)
2. **ACK**：服务器收到客户端的 FIN 包后，发送一个 ACK 包作为应答，确认客户端关闭连接的请求。此时，服务器仍然可以继续发送数据给客户端。
   **服务器**：ACK (Acknowledgement Number = U + 1)
3. **FIN**：服务器准备好关闭连接时，发送一个带 FIN 标志的数据包给客户端，表示服务器没有数据发送，准备关闭连接。
   **服务器**：FIN (Sequence Number = V)
4. **ACK**：客户端收到服务器的 FIN 包后，发送一个确认包（ACK）给服务器，表示客户端确认关闭连接。
   **客户端**：ACK (Acknowledgement Number = V + 1)



总结

客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在**网络拥堵**情况下：

- 一个「旧 SYN 报文」比「最新的 SYN」报文早到达了服务端，那么此时服务端就会回一个 `SYN + ACK` 报文给客户端，此报文中的确认号是 91（90+1）。
- 客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。
- 服务端收到 RST 报文后，就会释放连接。
- 后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。

上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的**最主要原因就是防止「历史连接」初始化了连接**。



服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，**但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序**：

- 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；
- 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，

**三次握手过程中可以携带数据吗**

- 第一次、第二次握手不可以携带数据，因为一握二握时还没有建立连接，会让服务器容易受到攻击
- 而第三次握手，此时客户端已经处于 `ESTABLISHED (已建立连接状态)` ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的。



#### TCP如何保证页面文件能被完整送达浏览器

1. **分段和重组**
   - **分段（Segmentation）**：当服务器发送数据时，TCP协议会把数据切分成多个小块，称为数据段（Segments）。每个数据段包含数据的一部分，以及TCP头部信息（如序列号、确认号等）。
   - **重组（Reassembly）**：浏览器（接收端）收到多个数据段后，会根据每个段的序列号对它们进行重组，确保数据的顺序正确。即使数据段到达的顺序是错乱的，接收端也能够根据序列号进行排序。

2. **数据确认和重传机制（可靠传输）**
   - **确认（Acknowledgment）**：接收方会对每个收到的数据段发送确认信息（ACK）。这意味着接收方会告诉发送方它已经成功接收了哪些数据段。每个ACK中会包含下一个期望接收的数据段的序列号。
   - **重传机制（Retransmission）**：如果发送方在超时时间内没有收到某个数据段的确认，它会重新发送该数据段。这保证了即使数据丢失，TCP也能确保数据最终到达目标。



### IP篇

IP 在 TCP/IP 参考模型中处于第三层，也就是**网络层**。

网络层的主要作用是：**实现主机与主机之间的通信，也叫点对点（end to end）通信。**

**MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**

在网络中数据包传输中，**源 IP 地址和目标 IP 地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化（因为MAC地址对应的是点对点传播，纬度更小，类似于换乘，因此变换的起点和终点MAC地址都不过是中间点）。**

#### IP地址

IP 地址是每个连接到网络的设备的唯一标识符。IP 地址有两个主要版本：IPv4 和 IPv6。

##### IPv4

IPv4（Internet Protocol version 4）是最常见的 IP 地址格式，通常用于大多数互联网通信。它由 32 位二进制数表示，通常写成四个十进制数字，每个数字的范围是 0 到 255（例如：192.168.0.1）。

##### IPv6

IPv6（Internet Protocol version 6）是为了解决 IPv4 地址枯竭问题而设计的，使用 128 位地址，因此其地址空间比 IPv4 更大。

#### IP分类

- **公有 IP 地址**：公有 IP 地址是互联网上唯一的地址，可以通过互联网路由访问。公有 IP 地址由 **互联网服务提供商（ISP）** 分配给用户或组织。
- **私有 IP 地址**：私有 IP 地址用于局域网（LAN）中的设备，不能直接通过互联网访问。
- **回环地址**：回环地址（Loopback Address）是指计算机自身的 IP 地址，用于测试本地网络。IPv4 中，回环地址是 127.0.0.1，也称为 localhost。
- **广播地址**：广播地址是指在同一网络中向所有设备发送数据的地址。在 IPv4 中，广播地址通常是网络地址的最后一个地址，如 192.168.1.255。

#### 子网掩码

子网掩码用于将一个 IP 地址划分为网络部分和主机部分。它是一个 32 位的数字，与 IP 地址进行“按位与”运算，用于确定 IP 地址的网络和主机部分。

**子网掩码的格式**：类似于 IP 地址，通常是 255.255.255.0 或类似的格式。它的作用是将 IP 地址中的前几个部分标识为网络地址，剩下的部分标识为主机地址。

#### NAT(网络地址转换)

NAT（Network Address Translation，网络地址转换）是一种技术，用来改变 IP 数据包中的源或目标 IP 地址，使得多个设备能够共享一个公共的 IP 地址，从而节省 IP 地址并提高网络安全性。

1. **私有 IP 地址与公共 IP 地址的映射**：NAT 设备需要为每个私有 IP 地址创建与之对应的公共 IP 地址。假设私有网络中有 100 个设备，而 NAT 路由器只拥有 10 个公共 IP 地址。这时，NAT 路由器需要通过某种方式在这些私有设备与公共 IP 地址之间进行映射。
2. **动态分配公共 IP 地址**：当一个私有 IP 地址（例如 192.168.1.2）需要与外部网络进行通信时，NAT 路由器会选择一个公共 IP 地址，并将该公共 IP 地址与 192.168.1.2 之间建立一个映射关系。

#### DNS解析

DNS（Domain Name System，域名系统）是互联网中的一项关键技术，它的作用是将用户访问的**域名**（如 www.example.com）解析成对应的**IP 地址**（如 192.0.2.1），使得计算机能够通过IP地址与其他计算机进行通信。

DNS（域名系统）底层使用的是 **UDP**（用户数据报协议）作为其主要的传输协议。UDP 因为其无连接、低延迟的特性，非常适合 DNS 查询和响应的需求。

在 DNS 中，通常会使用端口 **53**。

DNS解析示意图

```markdown
客户端请求 -> 本地DNS缓存检查 -> DNS服务器查询 -> 根DNS服务器 -> 顶级域名DNS服务器 -> 权威DNS服务器 -> 返回IP地址 -> 浏览器访问网站
```

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）



#### 为什么HTTP协议下会使用TCP协议作为底层协议栈，为什么不用UDP？

HTTP 协议选择使用 **TCP**（传输控制协议）而非 **UDP**（用户数据报协议）作为底层协议栈，HTTP 主要是面向请求/响应的应用，它要求每次请求和响应都能可靠传输。TCP 提供的上述特性（可靠传输、数据顺序、流量控制、数据完整性等）对于 HTTP 这种要求高可靠性的协议至关重要。

1. **可靠性**

   **TCP** 是一种面向连接的协议，提供可靠的数据传输。它通过数据确认（acknowledgment）和重传机制确保数据的可靠到达。如果数据包丢失或损坏，TCP 会自动进行重传。

   **UDP** 则是无连接的协议，它不提供任何确认机制，也不保证数据的顺序或完整性。因此，使用 UDP 时，数据可能会丢失、重复或乱序，而这些情况在很多应用场景下是不允许的。

2. **顺序控制**

3.  **流量控制和拥塞控制**

4. **数据完整性**

5.  **连接管理**

##### TCP使用场景

- **Web浏览（HTTP/HTTPS）**
- **电子邮件（SMTP, IMAP, POP3）**
- **文件传输（FTP, SFTP）**

##### UDP使用场景

- **实时通信（VoIP, 视频会议）**
- **视频流和音频流**
- **在线游戏**
- **DNS 查询**



### 网络安全

#### 中间人攻击

为什么需要CA认证机构颁发证书？ 我们假设如果不存在认证机构，则人人都可以制造证书，这就带来了"中间人攻击"问题。

- 客户端请求被劫持，将所有的请求发送到中间人的服务器
- 中间人服务器返回自己的证书
- 客户端创建随机数，使用中间人证书中的公钥进行加密发送给中间人服务器，中间人使用私钥对随机数解密并构造对称加密，对之后传输的内容进行加密传输
- 中间人通过客户端的随机数对客户端的数据进行解密
- 中间人与服务端建立合法的https连接（https握手过程），与服务端之间使用对称加密进行数据传输，拿到服务端的响应数据，并通过与服务端建立的对称加密的秘钥进行解密
- 中间人再通过与客户端建立的对称加密对响应数据进行加密后传输给客户端
- 客户端通过与中间人建立的对称加密的秘钥对数据进行解密

CA证书中会包含颁发机构信息、公钥、公司信息、域名、有效期等信息



#### XSS攻击**（跨站脚本攻击）**

XSS（Cross-Site Scripting）是一种常见的网络攻击方式，攻击者通过向网页中注入恶意脚本（JavaScript）来攻击用户。恶意脚本会在用户的浏览器中执行，从而盗取用户数据（如 Cookie），修改页面内容，或者执行其他恶意操作。

解决方案：对输入内容进行过滤，比如去掉 <script> 这些危险标签

#### CSRF(跨站请求伪造)

CSRF（Cross-Site Request Forgery）是一种攻击方式，攻击者诱使已登录的用户在不知情的情况下发起一个伪造的请求，攻击者通过在受害者的浏览器中发送请求，操作用户的账户或进行其他恶意操作。

用户点击恶意网站内的重要网站链接，浏览器在向重要网站发送请求时有setcookie，就可以得到服务器的回应

**CSRF 攻击的核心在于用户在已登录状态下访问了恶意网站，而浏览器在请求时会自动携带重要网站的 Cookie**，导致服务器误以为是合法用户的请求，从而执行了攻击者构造的操作。

#### CORS**（跨源资源共享）**

CORS（Cross-Origin Resource Sharing）是一种浏览器机制，用于允许或阻止不同源的网页请求访问当前源的资源。浏览器出于安全考虑，默认阻止跨域请求，但 CORS 提供了一种方式来允许跨域请求。

- 浏览器会在发起跨域请求时，自动发送一个 **预检请求**（OPTIONS 请求），询问服务器是否允许该请求。服务器可以通过设置 Access-Control-Allow-Origin 等响应头来告诉浏览器允许或拒绝该跨域请求。
- 如果预检请求成功，浏览器会继续发送实际请求（如 GET、POST）。